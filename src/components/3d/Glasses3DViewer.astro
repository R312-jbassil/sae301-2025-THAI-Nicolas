---
// Composant 3D pour afficher le modÃ¨le de lunettes interactif
---

<div id="glasses-3d-container" class="w-full h-[400px] sm:h-[600px] lg:h-[800px] flex items-center justify-center relative group">
	<canvas id="glasses-canvas" class="absolute w-full sm:w-[1500px] lg:w-[2000px] h-[400px] sm:h-[600px] lg:h-[800px]"></canvas>
	
	<!-- Indicateur d'interaction -->
	<div class="hidden absolute bottom-4 left-1/2 -translate-x-1/2 bg-noir/70 text-white px-4 py-2 rounded-full text-sm opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">
		ğŸ–±ï¸ Cliquez et glissez pour faire tourner
	</div>
	
	<!-- Debug info -->
	<div id="debug-info" class="hidden absolute top-4 left-4 bg-white/90 p-2 rounded text-xs font-mono">
		<div>Canvas: <span id="canvas-size">-</span></div>
		<div>Container: <span id="container-size">-</span></div>
		<div>Camera near/far: <span id="camera-planes">-</span></div>
		<div>Controls dist: <span id="controls-dist">-</span></div>
		<div>Model bounds: <span id="model-bounds">-</span></div>
	</div>
	
	<!-- Panneau de contrÃ´le pour ajuster la position (mode dÃ©veloppement) -->
	<div id="debug-controls" class="hidden absolute top-4 right-4 bg-white/90 p-4 rounded-lg shadow-lg text-sm space-y-2 z-50">
		<div class="font-bold text-noir mb-2">ğŸ›ï¸ ContrÃ´les 3D</div>
		
		<div>
			<label class="text-gris">Position X:</label>
			<input type="range" id="posX" min="-5" max="5" step="0.1" value="0" class="w-full">
			<span id="posX-val" class="text-vert">0</span>
		</div>
		
		<div>
			<label class="text-gris">Position Y:</label>
			<input type="range" id="posY" min="-5" max="5" step="0.1" value="0" class="w-full">
			<span id="posY-val" class="text-vert">0</span>
		</div>
		
		<div>
			<label class="text-gris">Position Z:</label>
			<input type="range" id="posZ" min="-5" max="5" step="0.1" value="0" class="w-full">
			<span id="posZ-val" class="text-vert">0</span>
		</div>
		
		<div>
			<label class="text-gris">Rotation Y:</label>
			<input type="range" id="rotY" min="-3.14" max="3.14" step="0.01" value="0" class="w-full">
			<span id="rotY-val" class="text-vert">0</span>
		</div>
		
		<div>
			<label class="text-gris">Ã‰chelle:</label>
			<input type="range" id="scale" min="1" max="30" step="0.5" value="15" class="w-full">
			<span id="scale-val" class="text-vert">15</span>
		</div>
		
		<div>
			<label class="text-gris">CamÃ©ra Z:</label>
			<input type="range" id="camZ" min="0.5" max="10" step="0.1" value="3" class="w-full">
			<span id="camZ-val" class="text-vert">3</span>
		</div>
		
		<button id="copyValues" class="w-full bg-vert text-white px-3 py-1 rounded mt-2 hover:bg-vert/80">
			ğŸ“‹ Copier les valeurs
		</button>
	</div>
</div>

<script>
	import * as THREE from 'three';
	import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
	import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

	// Configuration de la scÃ¨ne 3D
	function init3DScene() {
		const container = document.getElementById('glasses-3d-container');
		const canvas = document.getElementById('glasses-canvas') as HTMLCanvasElement;
		
		if (!container || !canvas) {
			console.error('Container ou canvas 3D introuvable');
			return;
		}

		// Dimensions FIXES pour avoir un canvas trÃ¨s large (pas limitÃ© par le conteneur)
		const width = 2000;  // Canvas trÃ¨s large
		const height = 1600; // Canvas trÃ¨s haut
		
		console.log('ğŸ” === DIAGNOSTIC 3D SCENE ===');
		console.log('ğŸ“ Container dimensions:', { width, height });
		console.log('ğŸ“¦ Container element:', container);
		console.log('ğŸ¨ Canvas element:', canvas);

		// ScÃ¨ne
		const scene = new THREE.Scene();
		scene.background = null; // Transparent pour s'intÃ©grer au design

		// CamÃ©ra - Configuration optimale pour Ã©viter le clipping
		const camera = new THREE.PerspectiveCamera(75, width / height, 0.01, 2000);
		camera.position.set(0, 0, 10.1);
		camera.lookAt(0, 0, 0);
		
		console.log('ğŸ“· Camera config:', {
			fov: camera.fov,
			aspect: camera.aspect,
			near: camera.near,
			far: camera.far,
			position: camera.position
		});

		// Renderer avec viewport Ã©largi
		const renderer = new THREE.WebGLRenderer({
			canvas: canvas,
			antialias: true,
			alpha: true, // Transparence activÃ©e
			preserveDrawingBuffer: true
		});
		renderer.setSize(width, height);
		renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
		renderer.setScissorTest(false);
		renderer.setViewport(0, 0, width, height);
		
		console.log('ğŸ¨ Renderer config:', {
			size: { width, height },
			pixelRatio: renderer.getPixelRatio(),
			scissorTest: renderer.getScissorTest(),
			viewport: renderer.getViewport(new THREE.Vector4())
		});

		// ContrÃ´les interactifs (manipulation Ã  la souris)
		const controls = new OrbitControls(camera, canvas);
		controls.enableDamping = true; // Animation fluide
		controls.dampingFactor = 0.1; // SensibilitÃ© rÃ©duite (0.05 â†’ 0.1)
		controls.rotateSpeed = 0.5; // Vitesse de rotation rÃ©duite
		controls.enableZoom = false; // Zoom dÃ©sactivÃ©
		controls.enablePan = false; // Pan dÃ©sactivÃ©
		controls.target.set(0, -2.7, 0);
		
		// Limites de rotation (empÃªche de faire un tour complet)
		controls.minAzimuthAngle = -Math.PI / 3; // -60Â° (limite gauche)
		controls.maxAzimuthAngle = Math.PI / 3;  // +60Â° (limite droite)
		controls.minPolarAngle = Math.PI / 2.5;  // Limite haut
		controls.maxPolarAngle = Math.PI / 1.5;  // Limite bas
		
		console.log('ğŸ® OrbitControls config:', {
			minDistance: controls.minDistance,
			maxDistance: controls.maxDistance,
			target: controls.target,
			enableDamping: controls.enableDamping,
			enableZoom: controls.enableZoom,
			enablePan: controls.enablePan
		});

		// LumiÃ¨res
		const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
		scene.add(ambientLight);

		const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
		directionalLight1.position.set(5, 5, 5);
		scene.add(directionalLight1);

		const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
		directionalLight2.position.set(-5, -5, -5);
		scene.add(directionalLight2);

		// Chargement du modÃ¨le
		const loader = new GLTFLoader();
		let glassesModel: THREE.Group | null = null;
		let isLoading = true;

		// Variables pour les contrÃ´les - Valeurs finales optimisÃ©es
		let modelPosX = 0.10, modelPosY = -2.70, modelPosZ = 0.10;
		let modelRotY = -1.55;
		let modelScale = 6.5;

		// Fonction pour configurer les contrÃ´les interactifs
		function setupControls(model: THREE.Group, maxDim: number) {
			const posXInput = document.getElementById('posX') as HTMLInputElement;
			const posYInput = document.getElementById('posY') as HTMLInputElement;
			const posZInput = document.getElementById('posZ') as HTMLInputElement;
			const rotYInput = document.getElementById('rotY') as HTMLInputElement;
			const scaleInput = document.getElementById('scale') as HTMLInputElement;
			const camZInput = document.getElementById('camZ') as HTMLInputElement;
			
			const posXVal = document.getElementById('posX-val');
			const posYVal = document.getElementById('posY-val');
			const posZVal = document.getElementById('posZ-val');
			const rotYVal = document.getElementById('rotY-val');
			const scaleVal = document.getElementById('scale-val');
			const camZVal = document.getElementById('camZ-val');
			
			const copyBtn = document.getElementById('copyValues');

			// Position X
			posXInput?.addEventListener('input', (e) => {
				const val = parseFloat((e.target as HTMLInputElement).value);
				model.position.x = val;
				if (posXVal) posXVal.textContent = val.toFixed(2);
			});

			// Position Y
			posYInput?.addEventListener('input', (e) => {
				const val = parseFloat((e.target as HTMLInputElement).value);
				model.position.y = val;
				if (posYVal) posYVal.textContent = val.toFixed(2);
			});

			// Position Z
			posZInput?.addEventListener('input', (e) => {
				const val = parseFloat((e.target as HTMLInputElement).value);
				model.position.z = val;
				if (posZVal) posZVal.textContent = val.toFixed(2);
			});

			// Rotation Y
			rotYInput?.addEventListener('input', (e) => {
				const val = parseFloat((e.target as HTMLInputElement).value);
				model.rotation.y = val;
				if (rotYVal) rotYVal.textContent = val.toFixed(2);
			});

			// Ã‰chelle
			scaleInput?.addEventListener('input', (e) => {
				const val = parseFloat((e.target as HTMLInputElement).value);
				const scale = val / maxDim;
				model.scale.setScalar(scale);
				if (scaleVal) scaleVal.textContent = val.toFixed(1);
			});

			// CamÃ©ra Z
			camZInput?.addEventListener('input', (e) => {
				const val = parseFloat((e.target as HTMLInputElement).value);
				camera.position.z = val;
				if (camZVal) camZVal.textContent = val.toFixed(1);
			});

			// Copier les valeurs
			copyBtn?.addEventListener('click', () => {
				const values = `
Position: { x: ${model.position.x.toFixed(2)}, y: ${model.position.y.toFixed(2)}, z: ${model.position.z.toFixed(2)} }
Rotation Y: ${model.rotation.y.toFixed(2)}
Scale: ${scaleInput?.value || '15'}
Camera Z: ${camera.position.z.toFixed(1)}
				`.trim();
				
				navigator.clipboard.writeText(values);
				if (copyBtn) {
					const originalText = copyBtn.textContent;
					copyBtn.textContent = 'âœ… CopiÃ© !';
					setTimeout(() => { copyBtn.textContent = originalText; }, 2000);
				}
				
				console.log('ğŸ“‹ Valeurs copiÃ©es:', values);
			});
		}

		loader.load(
			'/3d/glasses.glb',
			(gltf) => {
				glassesModel = gltf.scene;
				
				// Centrer et ajuster l'Ã©chelle du modÃ¨le
				const box = new THREE.Box3().setFromObject(glassesModel);
				const center = box.getCenter(new THREE.Vector3());
				const size = box.getSize(new THREE.Vector3());
				
				// Centrer le modÃ¨le
				glassesModel.position.sub(center);
				
				// Appliquer les valeurs finales optimisÃ©es
				const maxDim = Math.max(size.x, size.y, size.z);
				const scale = modelScale / maxDim;
				glassesModel.scale.setScalar(scale);
				
				// Position finale
				glassesModel.position.x = modelPosX;
				glassesModel.position.y = modelPosY;
				glassesModel.position.z = modelPosZ;
				
				// Rotation finale
				glassesModel.rotation.y = modelRotY;
				glassesModel.rotation.x = 0;
				glassesModel.rotation.z = 0;
				
				scene.add(glassesModel);
				isLoading = false;
				
				console.log('âœ… ModÃ¨le 3D chargÃ© avec succÃ¨s');
				console.log('ğŸ“ Taille du modÃ¨le:', size);
				console.log('ğŸ“ Max dimension:', maxDim);
				console.log('ğŸ¯ Ã‰chelle appliquÃ©e:', scale);
				console.log('ğŸ“ Position finale:', glassesModel.position);
				console.log('ğŸ”„ Rotation finale:', glassesModel.rotation);
				console.log('ğŸ“¦ Bounding box:', {
					min: box.min,
					max: box.max,
					center: center
				});
				
				// CRITICAL: VÃ©rifier si le modÃ¨le est dans le frustum de la camÃ©ra
				const frustum = new THREE.Frustum();
				const projScreenMatrix = new THREE.Matrix4();
				camera.updateMatrixWorld();
				projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
				frustum.setFromProjectionMatrix(projScreenMatrix);
				
				const isInFrustum = frustum.intersectsBox(box);
				console.log('ğŸ‘ï¸ ModÃ¨le visible dans frustum?', isInFrustum);
				
				if (!isInFrustum) {
					console.warn('âš ï¸ PROBLÃˆME: Le modÃ¨le est en dehors du frustum de la camÃ©ra!');
				}
				
				console.log('ğŸ” === FIN DIAGNOSTIC ===');
				
				// Activer les contrÃ´les aprÃ¨s chargement
				setupControls(glassesModel, maxDim);
			},
			(progress) => {
				const percent = (progress.loaded / progress.total) * 100;
				console.log(`ğŸ“¦ Chargement du modÃ¨le 3D: ${percent.toFixed(0)}%`);
			},
			(error) => {
				console.error('âŒ Erreur lors du chargement du modÃ¨le 3D:', error);
				isLoading = false;
				// Afficher un message d'erreur dans le DOM
				if (container) {
					container.innerHTML = `
						<div class="text-center text-gris">
							<p>Impossible de charger le modÃ¨le 3D</p>
							<p class="text-sm mt-2">VÃ©rifiez que le fichier glasses.glb existe</p>
						</div>
					`;
				}
			}
		);

		// Animation avec contrÃ´les interactifs et debug
		let animationFrameId: number;
		let rotationDirection = 1; // 1 = droite, -1 = gauche
		const baseRotation = -1.55; // Rotation de base
		const rotationAmplitude = 0.4; // Amplitude de l'oscillation (Â±0.4 rad â‰ˆ Â±23Â°)
		
		function animate() {
			animationFrameId = requestAnimationFrame(animate);

			// Rotation automatique en va-et-vient (oscillation)
			if (glassesModel && !isLoading) {
				// Calculer la nouvelle rotation
				const targetRotation = glassesModel.rotation.y + (0.002 * rotationDirection);
				
				// VÃ©rifier les limites et inverser la direction si nÃ©cessaire
				if (targetRotation > baseRotation + rotationAmplitude) {
					rotationDirection = -1; // Inverser vers la gauche
				} else if (targetRotation < baseRotation - rotationAmplitude) {
					rotationDirection = 1; // Inverser vers la droite
				}
				
				// Appliquer la rotation
				glassesModel.rotation.y = targetRotation;
			}

			// Mise Ã  jour des contrÃ´les pour l'animation fluide
			controls.update();

			// DEBUG: Afficher les informations en temps rÃ©el
			const canvasSizeEl = document.getElementById('canvas-size');
			const containerSizeEl = document.getElementById('container-size');
			const cameraPlanesEl = document.getElementById('camera-planes');
			const controlsDistEl = document.getElementById('controls-dist');
			const modelBoundsEl = document.getElementById('model-bounds');
			
			if (canvasSizeEl) canvasSizeEl.textContent = `${canvas.width}x${canvas.height}`;
			if (containerSizeEl) containerSizeEl.textContent = `${container?.clientWidth}x${container?.clientHeight}`;
			if (cameraPlanesEl) cameraPlanesEl.textContent = `near:${camera.near} far:${camera.far}`;
			if (controlsDistEl) controlsDistEl.textContent = `min:${controls.minDistance} max:${controls.maxDistance} current:${camera.position.distanceTo(controls.target).toFixed(2)}`;
			
			if (glassesModel && modelBoundsEl) {
				const box = new THREE.Box3().setFromObject(glassesModel);
				const size = box.getSize(new THREE.Vector3());
				modelBoundsEl.textContent = `${size.x.toFixed(2)}x${size.y.toFixed(2)}x${size.z.toFixed(2)}`;
			}

			renderer.render(scene, camera);
		}

		animate();

		// Gestion du redimensionnement
		function handleResize() {
			if (!container) return;
			
			const newWidth = container.clientWidth;
			const newHeight = container.clientHeight;

			camera.aspect = newWidth / newHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(newWidth, newHeight);
		}

		window.addEventListener('resize', handleResize);

		// Nettoyage lors de la destruction du composant
		return () => {
			window.removeEventListener('resize', handleResize);
			cancelAnimationFrame(animationFrameId);
			controls.dispose();
			renderer.dispose();
			
			if (glassesModel) {
				scene.remove(glassesModel);
			}
		};
	}

	// Initialisation aprÃ¨s le chargement du DOM
	if (typeof window !== 'undefined') {
		document.addEventListener('DOMContentLoaded', () => {
			console.log('ğŸš€ Initialisation de la vue 3D...');
			init3DScene();
		});
	}
</script>

<style>
	#glasses-3d-container {
		position: relative;
		overflow: visible;
		pointer-events: none; /* Ne bloque pas les clics en dehors */
	}

	#glasses-canvas {
		position: absolute; /* CLEF: Position absolute pour dÃ©border */
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%); /* Centrage parfait */
		width: 2000px !important; /* Dimensions fixes pour Ã©viter le clipping */
		height: 1600px !important;
		display: block;
		z-index: 10; /* Au-dessus du conteneur */
		pointer-events: auto; /* Le canvas lui-mÃªme reste interactif */
	}
	
	/* Les Ã©lÃ©ments de debug restent interactifs */
	#debug-info,
	#debug-controls {
		pointer-events: auto;
		z-index: 20;
	}
</style>
